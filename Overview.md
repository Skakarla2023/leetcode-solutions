## âœ… 1. Array

What it is: A list of items (like numbers) stored in order.

When to use: When you're storing or processing elements in a fixed-size container.

Key idea: Access elements using indices, perform operations like sum, reverse, search, etc.

## ğŸ§µ 2. String

What it is: A sequence of characters, like words or sentences.

When to use: When working with text â€” checking for palindromes, substrings, formatting, etc.

Key idea: Use character-by-character manipulation, comparison, and built-in string methods.

## ğŸ§® 3. Hashing

What it is: A technique using hash maps (dictionaries) to store and find elements fast (in constant time).

When to use: When you need to count, lookup, or track duplicates quickly.

Key idea: Store values as key-value pairs so you can check things like "Have I seen this before?" instantly.

## â• 4. Prefix Sum

What it is: A way to quickly find the sum of numbers between two positions in an array.

When to use: When the question involves range sums, or cumulative effects (like "total calories eaten between day 2 and 5").

Key idea: Pre-calculate a running total so you can get subarray sums in constant time.

## ğŸ”¢ 5. Sorting

What it is: Arranging data in increasing or decreasing order.

When to use: When solving problems that require order, comparison, or finding minimum/maximum.

Key idea: Use built-in or custom sort logic to group or arrange data in a useful way.

## ğŸ” 6. Two Pointers

What it is: Using two indices to scan data from two directions (startâ€“end, leftâ€“right).

When to use: When the array is sorted, or when you want to compare elements or reduce time from O(nÂ²) to O(n).

Key idea: Move the pointers towards each other to efficiently narrow down possibilities.

## ğŸ“š 7. Dynamic Programming (DP)

What it is: Breaking a big problem into smaller overlapping subproblems, and storing their results to avoid repeating work.

When to use: When the problem has optimal substructure (can be built from smaller solutions) and overlapping subproblems.

Key idea: Save answers to previous steps to build up to the final answer.

## ğŸ¤‘ 8. Greedy

What it is: Make the best local choice at each step, hoping it leads to the global best solution.

When to use: When the problem can be solved step-by-step, and making early optimal decisions leads to an optimal outcome.

Key idea: No backtracking â€” just pick the best option right now.

## ğŸŒ³ 9. Tree (Binary Tree, BST, N-ary Tree)

What it is: A data structure where each node points to children (usually 2 in binary trees).

When to use: When you need to store hierarchical data or search/sort efficiently (like file systems, family trees, etc.).

Key idea: Use recursion or DFS/BFS to navigate the tree.

## ğŸŒ 10. Graph (DFS/BFS)

What it is: A network of nodes connected by edges (like cities and roads).

When to use: When working with relationships, networks, grids, or finding paths/connections.

Key idea: Use DFS (depth-first) or BFS (breadth-first) to explore the graph.
