## ✅ 1. Array

What it is: A list of items (like numbers) stored in order.

When to use: When you're storing or processing elements in a fixed-size container.

Key idea: Access elements using indices, perform operations like sum, reverse, search, etc.

## 🧵 2. String

What it is: A sequence of characters, like words or sentences.

When to use: When working with text — checking for palindromes, substrings, formatting, etc.

Key idea: Use character-by-character manipulation, comparison, and built-in string methods.

## 🧮 3. Hashing

What it is: A technique using hash maps (dictionaries) to store and find elements fast (in constant time).

When to use: When you need to count, lookup, or track duplicates quickly.

Key idea: Store values as key-value pairs so you can check things like "Have I seen this before?" instantly.

## ➕ 4. Prefix Sum

What it is: A way to quickly find the sum of numbers between two positions in an array.

When to use: When the question involves range sums, or cumulative effects (like "total calories eaten between day 2 and 5").

Key idea: Pre-calculate a running total so you can get subarray sums in constant time.

## 🔢 5. Sorting

What it is: Arranging data in increasing or decreasing order.

When to use: When solving problems that require order, comparison, or finding minimum/maximum.

Key idea: Use built-in or custom sort logic to group or arrange data in a useful way.

## 🔁 6. Two Pointers

What it is: Using two indices to scan data from two directions (start–end, left–right).

When to use: When the array is sorted, or when you want to compare elements or reduce time from O(n²) to O(n).

Key idea: Move the pointers towards each other to efficiently narrow down possibilities.

## 📚 7. Dynamic Programming (DP)

What it is: Breaking a big problem into smaller overlapping subproblems, and storing their results to avoid repeating work.

When to use: When the problem has optimal substructure (can be built from smaller solutions) and overlapping subproblems.

Key idea: Save answers to previous steps to build up to the final answer.

## 🤑 8. Greedy

What it is: Make the best local choice at each step, hoping it leads to the global best solution.

When to use: When the problem can be solved step-by-step, and making early optimal decisions leads to an optimal outcome.

Key idea: No backtracking — just pick the best option right now.

## 🌳 9. Tree (Binary Tree, BST, N-ary Tree)

What it is: A data structure where each node points to children (usually 2 in binary trees).

When to use: When you need to store hierarchical data or search/sort efficiently (like file systems, family trees, etc.).

Key idea: Use recursion or DFS/BFS to navigate the tree.

## 🌐 10. Graph (DFS/BFS)

What it is: A network of nodes connected by edges (like cities and roads).

When to use: When working with relationships, networks, grids, or finding paths/connections.

Key idea: Use DFS (depth-first) or BFS (breadth-first) to explore the graph.
